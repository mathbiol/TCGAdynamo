<!DOCTYPE html>

<html>
    <head>
        <title>GSoC_RPPA</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="three.min.js"></script>
        <script type="text/javascript" src="patient_data.js"></script>
        <script type="text/javascript" src="RPPA_data.js"></script>
        
        <script type="text/javascript" src="weights.js"></script>
        <script src="DAT.GUI.min.js"></script>
    </head>
    <body>
        <script>
            var data = JSON.parse(patient_data);
            
            var n_patients = data.patients.length;
            var n_features = data.patients[0].proteins.length;
            
            console.log(n_patients);
            
            //reads in a features x patients matrix where the features are the proteins
            //and the values are the RPPA values
            var features = [];
            for (var i=0;i<n_features;i++){
                features[i] = [];
                for (var k=0;k<n_patients;k++){
                    features[i][k] = parseFloat(data.patients[k].proteins[i].value);
                }
            }
            
            function compare_values(a,b){
                return a-b;
            }
            
            var survival = [];
            for (var i=0;i<n_patients;i++){
                survival[i] = parseInt(data.patients[i].clinical.death_days_to);
               
            }
            survival.sort(compare_values);
            var survival_ranks = {};
            var counter = 1;
            survival_ranks[survival[0]]=1;
            for (var i=1;i<n_patients;i++){
                if (survival[i]>survival[i-1]){
                    counter++;
                    survival_ranks[survival[i]]=counter;
                }
            }
            
            var survival_quantile = [];
            for (var i=0;i<n_patients;i++){
                survival_quantile[i] = survival_ranks[parseInt(data.patients[i].clinical.death_days_to)]/(Object.keys(survival_ranks).length+1);
                
            }
            
            
            
            function compute_quantile_features(){
                var quantile_features = [];
                
                var temp = [];
                var ranks = {};
                var counter = 1;
                for (var i=0;i<n_features;i++){
                    
                    for (var k=0;k<n_patients;k++){
                        temp[k] = features[i][k];
                    }
                    temp.sort(compare_values);
                    counter=1;
                    ranks = {};
                    ranks[temp[0]]=1;
                    for (var k=0;k<n_patients;k++){
                        if (temp[k]>temp[k-1]){
                            counter++;
                            ranks[temp[k]]=counter;
                        }
                    }
                    
                    quantile_features[i] = [];
                    for (var k=0; k<n_patients;k++){
                        quantile_features[i][k]=ranks[features[i][k]]/(Object.keys(ranks).length+1);
                        
                    }
                }
                return (quantile_features);
            }
            
            var quantile_features = compute_quantile_features();
            
            
            params = {}
            
            var gui = new dat.GUI();
            for (var i=0;i<n_features;i++){
                params[data.patients[0].proteins[i].ID]=true;
                gui.add(params,data.patients[0].proteins[i].ID);
            }
            
            function compute_euclidean_distance(index_a, index_b){
                var sum=0;
                for (var i=0;i<n_features;i++){
                    if (params[data.patients[0].proteins[i].ID]==true){
                        sum = sum+Math.pow(1*(features[i][index_a]-features[i][index_b]),2);
                    }
                }
                sum=Math.sqrt(sum);
                console.log(sum);
                
                return(sum);
            }
            
            
            var euclidean_distances = [];
            
            for (var i=0;i<n_patients-1;i++){
                euclidean_distances[i] = [];
                for (var k=i+1;k<n_patients;k++){
                    euclidean_distances[i][k] = compute_euclidean_distance(i,k);
                }
            }
            
            var edge_between = [];
            
            for (var i=0;i<n_patients;i++){
                edge_between[i] = [];
                for (var k=i+1;k<n_patients;k++){
                    patient_distance = euclidean_distances[i][k-(i+1)];
                    if (patient_distance<10){
                        edge_between[i][k] = 0;
                    }
                    else{
                        edge_between[i][k] = 0;
                    }    
                }
            }
            
            
            for (var i=0;i<n_patients;i++){
                min =1000;
                index = -1;
                best_k = [];
                indexes = [];
                counter_in_best = 0;
                for (var k=i+1;k<n_patients;k++){
                    patient_distance = euclidean_distances[i][k-(i+1)];
                    
                    if (counter_in_best<2){
                        best_k[counter_in_best]=patient_distance;
                        indexes[counter_in_best]=k;
                        counter_in_best++;
                    }
                    else{
                        for (var j=0;j<2;j++){
                            if (patient_distance<best_k[j]){
                                best_k[j]=patient_distance;
                                indexes[j]=k;
                            }
                        }
                    }
                }
                for (var j=0;j<2;j++)
                    edge_between[i][indexes[j]] = 1;
            }
            
            var degree_counter=0;
            var node_degree=[];
            for (var i=0;i<n_patients;i++){
                degree_counter=0;
                for (var k=i+1;k<n_patients;k++){
                    if (edge_between[i][k]==1){
                        degree_counter++;
                    }
                }
                node_degree[i]=degree_counter;
            }
            
            var scene = new THREE.Scene();
            var width = 800;
            var height = 800;
            
            var canvas = document.createElement('canvas');
            document.body.appendChild(canvas);
            
            var renderer = new THREE.WebGLRenderer({canvas: canvas,  antialiasing: true });
            renderer.setSize(width, height);
            
            var camera_parameter=30;
            camera = new THREE.OrthographicCamera( width*camera_parameter / - 2, width*camera_parameter / 2, height*camera_parameter / 2, height*camera_parameter / - 2, - 500, 1000 );
            camera.position.x = 0;
            camera.position.y = 0;
       	    camera.position.z = 100;
            
            var geometry = new THREE.SphereGeometry(150,0,0);
            var material = new THREE.MeshBasicMaterial( { color: new THREE.Color( 0,0,1 )} );
            
            var patient_points = [];
            
                
            for (var i=0;i<n_patients;i++){
                var scaled_value=survival_quantile[i];
                
                if (scaled_value<0.3){
                    b = scaled_value/0.3;
                    var material =new THREE.MeshBasicMaterial( { color: new THREE.Color( 0, 0, b ) } );
                    patient_points[i] = new THREE.Mesh( geometry, material);
                    random_x = (Math.random() * 750)- 390;
                    if (survival[i]>480){
                        random_y = (Math.random() * 750)+1390;
                    }
                    else{
                        random_y = (Math.random() * 750)-1390;  
                    }
                    patient_points[i].position.x = random_x;
                    patient_points[i].position.y = random_y;
                    scene.add(patient_points[i]);
                }
                else if(scaled_value<0.6){
                    g = (scaled_value-0.3)/0.3;
                    b = (-scaled_value+0.6)/0.3;
                    var material =new THREE.MeshBasicMaterial( { color: new THREE.Color( 0, g, b ) } );
                    patient_points[i] = new THREE.Mesh( geometry, material);
                    random_x = (Math.random() * 750)- 390;
                    if (survival[i]>480){
                        random_y = (Math.random() * 750)+1090;
                    }
                    else{
                        random_y = (Math.random() * 750)-1390;
                    }
                    patient_points[i].position.x = random_x;
                    patient_points[i].position.y = random_y;
                    scene.add(patient_points[i]);
                }
                else{
                    r = (scaled_value-0.6)/0.4;
                    g = (-scaled_value+1)/0.4;
                    var material =new THREE.MeshBasicMaterial( { color: new THREE.Color( r, g, 0 ) } );
                    patient_points[i] = new THREE.Mesh( geometry, material);
                    random_x = (Math.random() * 750)- 390;
                    if (survival[i]>480){
                        random_y = (Math.random() * 750)+1390;
                    }
                    else{
                        random_y = (Math.random() * 750)-1390;  
                    }
                    patient_points[i].position.x = random_x;
                    patient_points[i].position.y = random_y;
                    scene.add(patient_points[i]);
                }
            }
                
            
            
            var Fr = 0;
            var Fa = 0;
            var Fg = 0;
            var distance = 0;
            var kr = -800;
            var kg = 0.008;
            var Ftotal = 0;
            var vector_between_x;
            var vector_between_y;
            var gravity_vector_x;
            var gravity_vector_y;
            var gravity_vector_length;
            var velocity;
            function update(){
                //go over all nodes..
                for (var i=0;i<n_patients;i++){
                    //..and for each  node over all other nodes 
                    for (var k=i+1;k<n_patients;k++){
                        
                            
                            distance = Math.sqrt(Math.pow((patient_points[i].position.x-patient_points[k].position.x),2)+Math.pow((patient_points[i].position.y-patient_points[k].position.y),2));
                            vector_between_x = patient_points[i].position.x-patient_points[k].position.x;
                            vector_between_y = patient_points[i].position.y-patient_points[k].position.y;
                            vector_between_x = vector_between_x/distance;
                            vector_between_y = vector_between_y/distance;
                            
                            //compute Fr as suggested in the paper
                            Fr = kr*(4/distance);
                            
                            //if the two patients are similar comptue Fa, else set Fa=0
                            if (edge_between[i][k]==1){
                                Fa = Math.log((1+distance));
                            }
                            else{
                                Fa=0;
                            }
                            Ftotal = Fr + Fa;
                        
                            //set new positions
                            patient_points[k].position.x=patient_points[k].position.x+vector_between_x*Ftotal*0.8;
                            patient_points[k].position.y=patient_points[k].position.y+vector_between_y*Ftotal*0.8;
                
                            patient_points[i].position.x=patient_points[i].position.x-vector_between_x*Ftotal*0.8;
                            patient_points[i].position.y=patient_points[i].position.y-vector_between_y*Ftotal*0.8;
                       
                    }
                }
                //finally go over all nodes and compute the gravity
                for (var i=0;i<n_patients;i++){
                    gravity_vector_x=-patient_points[i].position.x;
                    gravity_vector_y=-patient_points[i].position.y;
                    
                    gravity_vector_length=Math.sqrt(Math.pow(gravity_vector_x,2)+Math.pow(gravity_vector_y,2));
                    
                    Fg = kg*(node_degree[i]+1)*gravity_vector_length;
                    
                    gravity_vector_x=gravity_vector_x/gravity_vector_length;
                    gravity_vector_y=gravity_vector_y/gravity_vector_length;
                    patient_points[i].position.x=patient_points[i].position.x+gravity_vector_x*Fg*0.8;
                    patient_points[i].position.y=patient_points[i].position.y+gravity_vector_y*Fg*0.8;
                }
            }
            
            function render(){
                update();
                renderer.render( scene, camera );
            }
            
            function recompute(){
                
                for (var i=0;i<n_patients-1;i++){
                    for (var k=i+1;k<n_patients;k++){
                        euclidean_distances[i][k] = compute_euclidean_distance(i,k);
                    } 
                }
                
                for (var i=0;i<n_patients;i++){
                    for (var k=i+1;k<n_patients;k++){
                        patient_distance = euclidean_distances[i][k-(i+1)];
                        if (patient_distance<4){
                            edge_between[i][k] = 1;
                        }
                        else{
                            edge_between[i][k] = 0;
                        }  
                }
            }
            
            var degree_counter=0;
            for (var i=0;i<n_patients;i++){
                degree_counter=0;
                for (var k=i+1;k<n_patients;k++){
                    if (edge_between[i][k]==1){
                        degree_counter++;
                    }
                }
                node_degree[i]=degree_counter;
            }
                
            }
            
            
            
            var gui = new dat.GUI();
            for (var i=0;i<n_features;i++){
                //gui.add(this, data.patients[0].proteins[i].ID);
            }
            gui.add(this,'recompute');
            setInterval(render, 1000/200);
            render();
        </script>
        
        <div></div>
    </body>
</html>
