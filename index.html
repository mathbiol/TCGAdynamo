<html>
    <head>
        <title>GSoC Baseline Study</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script type="text/javascript" src="patient_data.js"></script>
        <style>
			body { margin: 0}
			canvas { margin: 0}
        </style>
        <script src="three.min.js"></script>
    </head>
    <body>
        <script>
            
            //I genereated a json file which contains a subset of the complete patient list
            //this json file contains 50 patients and for each patient I extracted the following attributes:
            //      -bcr patient uuid
            //      -age at initial pathologic diagnosis
            //      -karnofksy score
            //      -histological type
            //      -death days to
            //      -last contact days to
            //      -vital status
            //      -birth days to 
            //      -gender
            //In this first experiment I only use "age", "karnofsky score" and "death days to"
            var data = JSON.parse(patients);
            console.log("data contains "+data.patients.length+" patients");
            var n = data.patients.length;
            
            //first I parse the json file to extract the attributes for each patient
            //into arrays
            var all_ages = [];
            var all_karnofsky_scores = [];
            var all_death_days_to = [];
            function get_all_values(){
                data.patients.forEach(function(patient, i){
                    all_ages[i]=parseInt(data.patients[i].age_at_initial_pathologic_diagnosis);
                    all_karnofsky_scores[i]=parseInt(data.patients[i].karnofsky_score);
                    all_death_days_to[i]=parseInt(data.patients[i].death_days_to);
                });
            }
            get_all_values();
            
            //now I sort the values and create a "rank map" (see create_rank_maps()) which I use afterwards 
            //to compute the quantile vectors (see compute_quantile_vectors())
            function compare_values(a,b){
                return a-b;
            }
            all_ages.sort(compare_values);
            all_karnofsky_scores.sort(compare_values);
            all_death_days_to.sort(compare_values);
            
            var ages_ranks = {};
            var karnofsky_score_ranks = {};
            var death_days_to_ranks = {};
            function create_rank_maps(){
                var counter = 1;
                ages_ranks[all_ages[0]]=1;
                for (var i=1;i<n;i++){
                    if (all_ages[i]>all_ages[i-1]){
                        counter++;
                        ages_ranks[all_ages[i]]=counter;
                    }
                }
                counter=1;
                karnofsky_score_ranks[all_karnofsky_scores[0]]=1;
                for (var i=1;i<n;i++){
                    if (all_karnofsky_scores[i]>all_karnofsky_scores[i-1]){
                        counter++;
                        karnofsky_score_ranks[all_karnofsky_scores[i]]=counter;
                    }
                }
                counter=1;
                death_days_to_ranks[all_death_days_to[0]]=1;
                for (var i=1;i<n;i++){
                    if (all_death_days_to[i]>all_death_days_to[i-1]){
                        counter++;
                        death_days_to_ranks[all_death_days_to[i]]=counter;
                    }
                }
            }
            create_rank_maps();
           
            var patient_vectors = [];
            function compute_quantile_vectors(){
                
                var age_quantile;
                var karnofsky_score_quantile;
                var death_days_to_quantile;
                data.patients.forEach(function(patient, i){
                    
                    age_quantile = ages_ranks[parseInt(patient.age_at_initial_pathologic_diagnosis)]/(Object.keys(ages_ranks).length+1);
                    karnofsky_score_quantile = karnofsky_score_ranks[parseInt(patient.karnofsky_score)]/(Object.keys(karnofsky_score_ranks).length+1);
                    death_days_to_quantile = death_days_to_ranks[parseInt(patient.death_days_to)]/(Object.keys(death_days_to_ranks).length+1);
                    
                    patient_vectors[i] = {age_quantile: age_quantile, karnofsky_score_quantile: karnofsky_score_quantile, death_days_to_quantile: death_days_to_quantile};
                    
                });
                
            }
            compute_quantile_vectors();
            
            //now I go over all patient pairs and compute the euclidean distance between the patients
            var euclidean_distances = [];
            function compute_euclidean_distance(patient_a, patient_b){
                var age_quantile_diff = patient_vectors[patient_a].age_quantile-patient_vectors[patient_b].age_quantile;
                var karnofsky_score_diff = patient_vectors[patient_a].karnofsky_score_quantile-patient_vectors[patient_b].karnofsky_score_quantile;
                var death_days_to_diff = patient_vectors[patient_a].death_days_to_quantile-patient_vectors[patient_b].death_days_to_quantile;
                var sum = age_quantile_diff*age_quantile_diff+karnofsky_score_diff*karnofsky_score_diff+death_days_to_diff*death_days_to_diff;
                
                sum = Math.sqrt(sum);
                return(sum);
            }
            
            for (var i=0;i<n-1;i++){
                euclidean_distances[i] = [];
                for (var k=i+1;k<n;k++){
                   euclidean_distances[i][k-(i+1)]=compute_euclidean_distance(i,k);
                }
            }
            
            
            //next I go over all patient pairs again and check if the patients are similar (for example distance<0.2)
            //or not. If they are similar I set an edge between them which I use later to compute the forces
            //for the graph layout. Also I compute the degree of each patient node which is also used
            //for the force computation.
            var patient_distance;
            var edge_between = [];
            var node_degree = [];
            for (var i=0;i<n;i++){
                edge_between[i] = [];
                for (var k=i+1;k<n;k++){
                    patient_distance = euclidean_distances[i][k-(i+1)];
                    if (patient_distance<0.2){
                        edge_between[i][k] = 1;
                    }
                    else{
                        edge_between[i][k] = 0;
                    }
                        
                }
            }
            
            var degree_counter=0;
            for (var i=0;i<n;i++){
                degree_counter=0;
                for (var k=i+1;k<n;k++){
                    if (edge_between[i][k]==1){
                        degree_counter++;
                    }
                }
                node_degree[i]=degree_counter;
            }
            
            //here  is the point where the rendering starts.. you can skip until the next comment
            var scene = new THREE.Scene();
            var width = 800;
            var height = 800;
  
            var canvas = document.createElement('canvas');
            document.body.appendChild(canvas);
            var renderer = new THREE.WebGLRenderer({canvas: canvas});
            renderer.setSize(width, height);
            
            var scene = new THREE.Scene();
            var camera_parameter=15;
            camera = new THREE.OrthographicCamera( width*camera_parameter / - 2, width*camera_parameter / 2, height*camera_parameter / 2, height*camera_parameter / - 2, - 500, 1000 );
            camera.position.x = 0;
            camera.position.y = 0;
       	    camera.position.z = 10;
           
            var geometry = new THREE.SphereGeometry(45,0,0);
            var material = new THREE.MeshBasicMaterial( { color: new THREE.Color( 1, 0, 0 ) } );
            var green_material = new THREE.MeshBasicMaterial( { color: new THREE.Color( 0, 1, 0 ) } );
            var patient_points = [];
            
            //I assign a random point for each node at first. Also I give a green color to
            //the patients 6,7,14,39 and 47 (this is just a random group of similar patients
            //to illustrate the clustering  )
            
            var random_x;
            var random_y;
            for (var i=0;i<n;i++){
                if (i==6 || i==7 || i==14 || i==39 || i==47 || i==51){
                    patient_points[i] = new THREE.Mesh( geometry, green_material );
                }
                else{
                    patient_points[i] = new THREE.Mesh( geometry, material );
                }
                random_x = (Math.random() * 750)- 390;
                random_y = (Math.random() * 750)- 390;
                patient_points[i].position.x = random_x;
                patient_points[i].position.y = random_y;
                scene.add(patient_points[i]);
            }
            
            
            var counter=0;
            //in the update step I calculate the repulsion force Fr for each pair of nodes
            //If there is an edge between two nodes (which means that the two patients
            //are similar) I also compute the attraction force Fa. Finally I go over all nodes
            //again and compute a gravity which pulls the node to the center of the plane
            //so that the nodes dont float away
            var Fr = 0;
            var Fa = 0;
            var Fg = 0;
            var distance = 0;
            var kr = -150;
            var kg = 0.002;
            var Ftotal = 0;
            var vector_between_x;
            var vector_between_y;
            var gravity_vector_x;
            var gravity_vector_y;
            var gravity_vector_length;
            var velocity;
            function update(){
                //go over all nodes..
                for (var i=0;i<n;i++){
                    //..and for each  node over all other nodes 
                    for (var k=i+1;k<n;k++){
                        
                            
                            distance = Math.sqrt(Math.pow((patient_points[i].position.x-patient_points[k].position.x),2)+Math.pow((patient_points[i].position.y-patient_points[k].position.y),2));
                            vector_between_x = patient_points[i].position.x-patient_points[k].position.x;
                            vector_between_y = patient_points[i].position.y-patient_points[k].position.y;
                            vector_between_x = vector_between_x/distance;
                            vector_between_y = vector_between_y/distance;
                            
                            //compute Fr as suggested in the paper
                            Fr = kr*(4/distance);
                            
                            //if the two patients are similar comptue Fa, else set Fa=0
                            if (edge_between[i][k]==1){
                                Fa = Math.log((1+distance));
                            }
                            else{
                                Fa=0;
                            }
                            Ftotal = Fr + Fa;
                        
                            //set new positions
                            patient_points[k].position.x=patient_points[k].position.x+vector_between_x*Ftotal*0.8;
                            patient_points[k].position.y=patient_points[k].position.y+vector_between_y*Ftotal*0.8;
                
                            patient_points[i].position.x=patient_points[i].position.x-vector_between_x*Ftotal*0.8;
                            patient_points[i].position.y=patient_points[i].position.y-vector_between_y*Ftotal*0.8;
                       
                    }
                }
                //finally go over all nodes and compute the gravity
                for (var i=0;i<n;i++){
                    gravity_vector_x=-patient_points[i].position.x;
                    gravity_vector_y=-patient_points[i].position.y;
                    
                    gravity_vector_length=Math.sqrt(Math.pow(gravity_vector_x,2)+Math.pow(gravity_vector_y,2));
                    
                    Fg = kg*(node_degree[i]+1)*gravity_vector_length;
                    
                    gravity_vector_x=gravity_vector_x/gravity_vector_length;
                    gravity_vector_y=gravity_vector_y/gravity_vector_length;
                    patient_points[i].position.x=patient_points[i].position.x+gravity_vector_x*Fg*0.8;
                    patient_points[i].position.y=patient_points[i].position.y+gravity_vector_y*Fg*0.8;
                }
            }
            
            function render() {
                update();
                renderer.render( scene, camera );
            }
            
            setInterval(render, 1000/30);
            
            
            
        </script>
        <p id="text">"hallo"</p> 
        <script>
            document.getElementById("text").innerHTML = "the green dots represent the following patients:</br>patient 6: age "+data.patients[6].age_at_initial_pathologic_diagnosis+", karnofsky score: "+data.patients[6].karnofsky_score+", death days to: "+data.patients[6].death_days_to+"</br>patient 7: age "+data.patients[7].age_at_initial_pathologic_diagnosis+", karnofsky score: "+data.patients[7].karnofsky_score+", death days to: "+data.patients[7].death_days_to+"</br>patient 14: age "+data.patients[14].age_at_initial_pathologic_diagnosis+", karnofsky score: "+data.patients[14].karnofsky_score+", death days to: "+data.patients[14].death_days_to+"</br>patient 39: age "+data.patients[39].age_at_initial_pathologic_diagnosis+", karnofsky score: "+data.patients[39].karnofsky_score+", death days to: "+data.patients[39].death_days_to+"</br>patient 47: age "+data.patients[47].age_at_initial_pathologic_diagnosis+", karnofsky score: "+data.patients[47].karnofsky_score+", death days to: "+data.patients[47].death_days_to+"</br>patient 51: age "+data.patients[51].age_at_initial_pathologic_diagnosis+", karnofsky score: "+data.patients[51].karnofsky_score+", death days to: "+data.patients[51].death_days_to;
        </script>
    </body>
</html>
